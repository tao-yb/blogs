<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tao-yb.github.io","root":"/blogs/","images":"/blogs/images","scheme":"Muse","darkmode":false,"version":"8.13.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/blogs/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="javaer">
<meta property="og:url" content="https://tao-yb.github.io/blogs/index.html">
<meta property="og:site_name" content="javaer">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="tao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tao-yb.github.io/blogs/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>javaer</title>
  






  <noscript>
    <link rel="stylesheet" href="/blogs/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">javaer</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/blogs/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-tags"><a href="/blogs/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-about"><a href="/blogs/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">tao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blogs/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blogs/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blogs/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2024/03/28/Springboot%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E4%B8%8Enacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2024/03/28/Springboot%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E4%B8%8Enacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/" class="post-title-link" itemprop="url">Springboot的事件发布与nacos服务注册</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-03-28 20:50:21 / Modified: 20:58:35" itemprop="dateCreated datePublished" datetime="2024-03-28T20:50:21+08:00">2024-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Springcloud/" itemprop="url" rel="index"><span itemprop="name">Springcloud</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Springboot事件发布"><a href="#Springboot事件发布" class="headerlink" title="Springboot事件发布"></a>Springboot事件发布</h2><p>Spring在启动的过程中会发布各类事件。比如在准备环境阶段，准备ApplicationContext等。它发布各类事件，事件订阅方能在各个阶段处理相应的业务。如在准备环境阶段，会有事件订阅放用来读取配置文件等。</p>
<h2 id="Springboot-事件处理简介"><a href="#Springboot-事件处理简介" class="headerlink" title="Springboot 事件处理简介"></a>Springboot 事件处理简介</h2><p>Spring的事件发布者会持有相应的Listeners，在事件发布后，根据事件类型获取对应的Linsteners，事件发布者通过invokeLinstener回调事件监听方来对事件进行处理。</p>
<h3 id="Spring启动过程事件处理"><a href="#Spring启动过程事件处理" class="headerlink" title="Spring启动过程事件处理"></a>Spring启动过程事件处理</h3><p>以org.springframework.boot.SpringApplication#run(java.lang.String…)方法为例来说明：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext context = null;</span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();</span><br><span class="line">        configureHeadlessProperty();</span><br><span class="line">        SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">        listeners.starting();</span><br><span class="line">        try &#123;</span><br><span class="line">            ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">            ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">            configureIgnoreBeanInfo(environment);</span><br><span class="line">            Banner printedBanner = printBanner(environment);</span><br><span class="line">            context = createApplicationContext();</span><br><span class="line">            exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,</span><br><span class="line">                    new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">            prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            refreshContext(context);</span><br><span class="line">            afterRefresh(context, applicationArguments);</span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            if (this.logStartupInfo) &#123;</span><br><span class="line">                new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.started(context);</span><br><span class="line">            callRunners(context, applicationArguments);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>总体处理流程：</p>
<p>SpringApplication.run() –&gt; SpringApplicationRunListeners.starting()–&gt;EventPublishingRunListener.starting()–&gt;SimpleApplicationEventMulticaster.multicastEvent()–&gt;SimpleApplicationEventMulticaster.invokeListener()–&gt;SimpleApplicationEventMulticaster.doInvokeListener()–&gt;</p>
<p>最后在doInvokeListener总，来回调事件订阅方：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            listener.onApplicationEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ClassCastException ex) &#123;</span><br><span class="line">            String msg = ex.getMessage();</span><br><span class="line">            if (msg == null || matchesClassCastMessage(msg, event.getClass())) &#123;</span><br><span class="line">                // Possibly a lambda-defined listener which we could not resolve the generic event type for</span><br><span class="line">                // -&gt; let&#x27;s suppress the exception and just log a debug message.</span><br><span class="line">                Log logger = LogFactory.getLog(getClass());</span><br><span class="line">                if (logger.isTraceEnabled()) &#123;</span><br><span class="line">                    logger.trace(&quot;Non-matching event type for listener: &quot; + listener, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                throw ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其他说明：</p>
<ul>
<li><p>SpringApplicationRunListeners持有SpringApplicationRunListener接口对象EventPublishingRunListener  </p>
</li>
<li><p>EventPublishingRunListener 持有SimpleApplicationEventMulticaster，在EventPublishingRunListener初始化时会给相应SimpleApplicationEventMulticaster对象赋值</p>
</li>
</ul>
<h3 id="step1-获取listeners"><a href="#step1-获取listeners" class="headerlink" title="step1 获取listeners"></a>step1 获取listeners</h3><p>通过getRunListeners(args)获取到SpringApplicationRunListeners对象。SpringApplicationRunListeners是对SpringApplicationRunListener的进一步封装，它持有一个List。它的实现如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private SpringApplicationRunListeners getRunListeners(String[] args) &#123;</span><br><span class="line">        Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">        return new SpringApplicationRunListeners(logger,</span><br><span class="line">                getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从getSpringFactoriesInstances方法便知：它应该是从Spring.factories文件中读取的（别问我是怎么知道的）。果然，在Spring.factories中可以看到：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure>

<p>口说无凭，来看下面这图：</p>
<p><img src="https://pic2.zhimg.com/80/v2-783196f7e6498b4f4b90910c02e336d1_720w.webp"></p>
<p>EventPublishingRunListener</p>
<p>它的调用栈是在SpringApplicationRunListeners调用starting开始的。</p>
<p>此后，EventPublishingRunListen便开始了事件发布：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public EventPublishingRunListener(SpringApplication application, String[] args) &#123;</span><br><span class="line">        this.application = application;</span><br><span class="line">        this.args = args;</span><br><span class="line">        this.initialMulticaster = new SimpleApplicationEventMulticaster();</span><br><span class="line">        for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">            this.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public void starting() &#123;</span><br><span class="line">        this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>由上可知：</p>
<ul>
<li><p>它持有事件发布者initialMulticaster。它是一个SimpleApplicationEventMulticaster对象  </p>
</li>
<li><p>SimpleApplicationEventMulticaster是一个事件发布方，在EventPublishingRunListener的构造函数中，会初始化它发布的事件相关的listener。  </p>
</li>
<li><p>通过事件发布者，发布了一个ApplicationStartingEvent事件。</p>
</li>
</ul>
<h3 id="step2-事件处理"><a href="#step2-事件处理" class="headerlink" title="step2 事件处理"></a>step2 事件处理</h3><p>事件处理以SimpleApplicationEventMulticaster处理事件为例。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void multicastEvent(ApplicationEvent event) &#123;</span><br><span class="line">        multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123;</span><br><span class="line">        ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));</span><br><span class="line">        Executor executor = getTaskExecutor();</span><br><span class="line">        for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">            if (executor != null) &#123;</span><br><span class="line">                executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                invokeListener(listener, event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在发布事件时，会调用通过getApplicationListeners方法，根据实际事件event获取listener。通俗来说，就是获取到关注发布的事件的对象，然后通过invokeListener来进行回调</p>
<h2 id="nacos-服务注册"><a href="#nacos-服务注册" class="headerlink" title="nacos 服务注册"></a>nacos 服务注册</h2><h3 id="Springcloud-服务注册原理"><a href="#Springcloud-服务注册原理" class="headerlink" title="Springcloud 服务注册原理"></a>Springcloud 服务注册原理</h3><p>在介绍nacos服务注册前，先介绍下SpringCloud服务注册的原理：</p>
<p>SpringCloud服务注册，是基于Springboot的事件机制。在spring-cloud-common包的AbstractAutoServiceRegistration中，订阅了WebServerInitializedEvent事件，这样，Springcloud应用启动的时候的某一阶段会发布WebServerInitializedEvent事件。按照之前介绍的事件处理机制，AbstractAutoServiceRegistration的实现类可以接收到这个事件，继而实现服务注册。</p>
<p>AbstractAutoServiceRegistration在接收到WebServerInitializedEvent事件后的处理流程如下：</p>
<p>AbstractAutoServiceRegistration.onApplicationEvent–&gt; AbstractAutoServiceRegistration.bind–&gt;AbstractAutoServiceRegistration.start()–&gt;AbstractAutoServiceRegistration.register()–&gt;ServiceRegistry.register(getRegistration())实现服务注册。</p>
<p>在nacos 中，同样通过Spring-cloud定义的标准，实现了服务注册:</p>
<ul>
<li><p>NacosAutoServiceRegistration实现了AbstractAutoServiceRegistration  </p>
</li>
<li><p>NacosServiceRegistry实现了ServiceRegistry接口  </p>
</li>
<li><p>nacos在收到WebServerInitializedEvent事件后，调用NacosServiceRegistry实现了服务注册。</p>
</li>
</ul>
<p>根据Springboot的事件以及事件监听者的回调，基本上理清了nacos服务注册时的大致流程。但是还存在一个问题：WebServerInitializedEvent事件是什么时候，由谁发布的？</p>
<h3 id="Lifecycle与WebServerInitializedEvent事件发布与"><a href="#Lifecycle与WebServerInitializedEvent事件发布与" class="headerlink" title="Lifecycle与WebServerInitializedEvent事件发布与"></a>Lifecycle与WebServerInitializedEvent事件发布与</h3><p>众所周知：Spring ApplicationContext的核心方法refresh，会实例化所有singleton对象。来看看refresh中的最后一个方法finishRefresh：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void finishRefresh() &#123;</span><br><span class="line">        // Clear context-level resource caches (such as ASM metadata from scanning).</span><br><span class="line">        clearResourceCaches();</span><br><span class="line"></span><br><span class="line">        // Initialize lifecycle processor for this context.</span><br><span class="line">        initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">        // Propagate refresh to lifecycle processor first.</span><br><span class="line">        getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">        // Publish the final event.</span><br><span class="line">        publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line"></span><br><span class="line">        // Participate in LiveBeansView MBean, if active.</span><br><span class="line">        LiveBeansView.registerApplicationContext(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实际上，WebServerInitializedEvent也是在finishRefresh中完成发布的。</p>
<h3 id="WebServerInitializedEvent的发布过程"><a href="#WebServerInitializedEvent的发布过程" class="headerlink" title="WebServerInitializedEvent的发布过程"></a>WebServerInitializedEvent的发布过程</h3><p>AbstractApplicationContext.finishRefresh()–&gt;DefaultLifecycleProcessor.onRefresh()–&gt;</p>
<p>DefaultLifecycleProcessor.startBeans()–&gt;DefaultLifecycleProcessor.getLifecycleBeans()–&gt;DefaultLifecycleProcessor.doStart()–&gt;WebServerStartStopLifecycle.start-()</p>
<p>上面有一些DefaultLifecycleProcessor的内部类调用链路省略了，有兴趣可以看看：</p>
<p><img src="https://pic1.zhimg.com/80/v2-23a40f3f3aa4f5513b4db3ca98b38e28_720w.webp"></p>
<p>lifecycle调用链</p>
<p>总体来说，就是DefaultLifecycleProcessor会调用实现了Lifecycle接口的start方法，而WebServerStartStopLifecycle也实现了Lifecycle，因此会在此时被调用。</p>
<p>而WebServerStartStopLifecycle在它的start 方法中，会发布ServletWebServerInitializedEvent事件。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WebServerStartStopLifecycle(ServletWebServerApplicationContext applicationContext, WebServer webServer) &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">        this.webServer = webServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        this.webServer.start();</span><br><span class="line">        this.running = true;</span><br><span class="line">        this.applicationContext</span><br><span class="line">                .publishEvent(new ServletWebServerInitializedEvent(this.webServer, this.applicationContext));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>在Springcloud中，在程序启动过程中，使用的是Springboot中的ServletWebServerApplicationContext作为容器。在它实例化singleton对象后最后阶段会在运行finishRefresh方法时发布ServletWebServerInitializedEvent事件。</li>
<li>在nacos中，通过NacosAutoServiceRegistration监听到WebServerInitializedEvent事件（WebServerInitializedEvent继承自ServletWebServerInitializedEvent），然后调用NacosRegistration实现了服务的自动注册。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/11/02/ReentrantLock%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E7%9A%84%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/11/02/ReentrantLock%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E7%9A%84%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">ReentrantLock条件等待与唤醒的流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-11-02 10:16:46 / Modified: 10:18:04" itemprop="dateCreated datePublished" datetime="2022-11-02T10:16:46+08:00">2022-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>ReentrantLock 可以通过newCondition用做条件等待。条件不满足，则等待;被唤醒后则入对等待执行。</p>
<h1 id="AQS中的Node"><a href="#AQS中的Node" class="headerlink" title="AQS中的Node"></a><a href="#aqs%E4%B8%AD%E7%9A%84node"></a>AQS中的Node</h1><p>在AQS中，获取不到锁时，线程会被封装成Node结构，然后入队；条件等待中，也会将等待线程封装为node。回顾下Node主要结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;        //等待状态。-2表示处于等待需要被唤醒的节点</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">        //等待队列中的前一个节点</span><br><span class="line">        volatile Node prev;</span><br><span class="line"></span><br><span class="line">        //等待队列中的下一个节点</span><br><span class="line">        volatile Node next;</span><br><span class="line"></span><br><span class="line">        //等待队列中的线程</span><br><span class="line">        volatile Thread thread;</span><br><span class="line"></span><br><span class="line">        //指向condition中的等待的节点或者特定Shared node        </span><br><span class="line">        Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>在ConditonObject中，就是使用的Node：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID = 1173984872572414699L;</span><br><span class="line">        /** First node of condition queue. */</span><br><span class="line">        private transient Node firstWaiter;</span><br><span class="line">        /** Last node of condition queue. */</span><br><span class="line">        private transient Node lastWaiter;</span><br><span class="line"></span><br><span class="line">        /**         * Creates a new &#123;@code ConditionObject&#125; instance.         */</span><br><span class="line">        public ConditionObject() &#123; &#125;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class SignalTest &#123;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock = new ReentrantLock();</span><br><span class="line">        final Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        final Thread t1 = new Thread(() -&gt; &#123;            lock.lock();            try &#123;                log.debug(&quot;t1 get lock&quot;);                condition.await();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125; finally &#123;                lock.unlock();            &#125;        &#125;, &quot;t1&quot;);        t1.start();        TimeUnit.SECONDS.sleep(10);        lock.lock();        try &#123;            log.debug(&quot;main signal!&quot;);            condition.signal();        &#125; catch (Exception e) &#123;            lock.unlock();        &#125;finally &#123;        &#125;        log.debug(&quot;main over~~~&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17:03:14.540 [t1] DEBUG com.demo.exercise.SignalTest - t1 get lock</span><br><span class="line">17:03:24.551 [main] DEBUG com.demo.exercise.SignalTest - main signal!</span><br><span class="line">17:03:24.551 [main] DEBUG com.demo.exercise.SignalTest - main over~~~</span><br></pre></td></tr></table></figure>

<p>示例说明：由于主线程延迟10秒才会获取锁后，因此线程t1肯定会先执行。t1执行时，直接通过condition.await()释放锁并park自己。</p>
<h1 id="await等待后释放锁"><a href="#await等待后释放锁" class="headerlink" title="await等待后释放锁"></a><a href="#await%E7%AD%89%E5%BE%85%E5%90%8E%E9%87%8A%E6%94%BE%E9%94%81"></a>await等待后释放锁</h1><p>同synchronized中使用一样，在调用同步对象的wait方法后会释放锁。ReentrantLock中的Condition调用await后也会释放自己占用的锁。</p>
<h2 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a><a href="#await%E6%B5%81%E7%A8%8B"></a>await流程</h2><p>先看看它的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致流程如下：</p>
<ol>
<li>如果线程被打断，那么直接抛出异常</li>
<li>将当前线程封装为一个等待的Node对象</li>
<li>通过fullyRelease释放锁</li>
<li>如果当前await的线程是一个等待signal信号的或者它的上一个节点为null，那就park 自己</li>
</ol>
<h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a><a href="#addconditionwaiter"></a>addConditionWaiter</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">       Node t = lastWaiter;</span><br><span class="line">       // If lastWaiter is cancelled, clean out.</span><br><span class="line">       if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">           unlinkCancelledWaiters();</span><br><span class="line">           t = lastWaiter;</span><br><span class="line">       &#125;</span><br><span class="line">       Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">       if (t == null)</span><br><span class="line">           firstWaiter = node;            else</span><br><span class="line">           t.nextWaiter = node;            lastWaiter = node;            return node;        &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法其实就是将线程封装为一个Node(此时waitStaus&#x3D;-2)。</p>
<h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a><a href="#fullyrelease"></a>fullyRelease</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">final int fullyRelease(Node node) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        int savedState = getState();</span><br><span class="line">        if (release(savedState)) &#123;</span><br><span class="line">            failed = false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">        int c = getState() - releases;</span><br><span class="line">        if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        boolean free = false;</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            free = true;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        return free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>几个核心的方法就是上面几个：</p>
<ol>
<li>获取AQS 中state值</li>
<li>然后通过release中调用tryRelease，设置state值以及将独占线程设置为Null。这个操作主要是让下一个线程可以来抢锁</li>
</ol>
<h2 id="signal-主要流程"><a href="#signal-主要流程" class="headerlink" title="signal 主要流程"></a><a href="#signal-%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B"></a>signal 主要流程</h2><p>先看源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">         if (!isHeldExclusively())</span><br><span class="line">             throw new IllegalMonitorStateException();</span><br><span class="line">         Node first = firstWaiter;</span><br><span class="line">         if (first != null)</span><br><span class="line">             doSignal(first);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">      * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="line">      * null. Split out from signal in part to encourage compilers</span><br><span class="line">      * to inline the case of no waiters.</span><br><span class="line">      * @param first (non-null) the first node on condition queue</span><br><span class="line">      */</span><br><span class="line">     private void doSignal(Node first) &#123;</span><br><span class="line">         do &#123;</span><br><span class="line">             if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">                 lastWaiter = null;</span><br><span class="line">             first.nextWaiter = null;</span><br><span class="line">         &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                  (first = firstWaiter) != null);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         /**</span><br><span class="line">  * Transfers a node from a condition queue onto sync queue.</span><br><span class="line">  * Returns true if successful.</span><br><span class="line">  * @param node the node</span><br><span class="line">  * @return true if successfully transferred (else the node was</span><br><span class="line">  * cancelled before signal)</span><br><span class="line">  */</span><br><span class="line"> final boolean transferForSignal(Node node) &#123;</span><br><span class="line">     /*</span><br><span class="line">      * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">      */</span><br><span class="line">     if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">         return false;</span><br><span class="line"></span><br><span class="line">     /*</span><br><span class="line">      * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">      * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">      * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">      * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">      */</span><br><span class="line">     Node p = enq(node);        int ws = p.waitStatus;</span><br><span class="line">     if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">         LockSupport.unpark(node.thread);</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>调用signal后：</p>
<ol>
<li>如果不是我占用了锁，此时释放直接抛异常</li>
<li>找condition队列的第一个等待线程，如果存在就将他唤醒</li>
</ol>
<p>在doSignal 方法中先对condition中的等待队列进行处理：将需要移入到AQS对列中的下一个节点置为Null。注意Node中只定义了nextWaiter，它是单向链表而非AQS中的双向</p>
<p>transferForSignal 方法流程：</p>
<ol>
<li>将等待节点的waitStatus先改为0。因为从condition队列中加入到AQS队列时，是放在AQS队列中的最后一个。而最后一个不需要唤醒其他人，所以状态是0</li>
<li>再调用enq方法，将node加入到AQS的队列</li>
<li>通过compareAndSetWaitStatus让从condition中入队到AQS中的节点被它的上一个节点叫醒。上面enq(node)返回的就是node 的上一个节点。</li>
</ol>
<p>最后， main 的lock.unlock 后，会唤醒AQS中的等待节点</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/11/01/Java%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/11/01/Java%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81/" class="post-title-link" itemprop="url">Java公平锁与非公平锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-11-01 21:04:22 / Modified: 21:07:40" itemprop="dateCreated datePublished" datetime="2022-11-01T21:04:22+08:00">2022-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>什么是公平锁与非公平锁?他们有什么区别? 我们平常使用的是公平锁还是非公平锁?</p>
<p>带着问题，首先来看ReentrantLock与synchronized加锁2个例子：</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><a href="#reentrantlock"></a>ReentrantLock</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.demo;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">/** * @author javaer * @Description * @create 2022-09-27 12:17 */</span><br><span class="line">@Slf4j</span><br><span class="line">public class ReetLock &#123;</span><br><span class="line"></span><br><span class="line">    private static final int COUNT = 10;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Thread&gt; threads = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    static ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            Thread thread = new Thread(() -&gt; &#123;                lock.lock();                try &#123;                    log.debug(&quot;&#123;&#125; print --&gt;&#123;&#125;&quot;, Thread.currentThread().getName(), finalI);                &#125; finally &#123;                    lock.unlock();                &#125;            &#125;, &quot;t&quot; + i);            threads.add(thread);        &#125;        lock.lock();        try &#123;            log.debug(&quot;main get lock &quot;);            for (int i = 0; i &lt; COUNT; i++) &#123;                threads.get(i).start();                TimeUnit.MICROSECONDS.sleep(50);            &#125;        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">18:02:31.468 [main] DEBUG com.demo.ReetLock - main get lock </span><br><span class="line">18:02:31.485 [t0] DEBUG com.demo.ReetLock - t0 print --&gt;0</span><br><span class="line">18:02:31.488 [t1] DEBUG com.demo.ReetLock - t1 print --&gt;1</span><br><span class="line">18:02:31.488 [t2] DEBUG com.demo.ReetLock - t2 print --&gt;2</span><br><span class="line">18:02:31.488 [t3] DEBUG com.demo.ReetLock - t3 print --&gt;3</span><br><span class="line">18:02:31.488 [t4] DEBUG com.demo.ReetLock - t4 print --&gt;4</span><br><span class="line">18:02:31.488 [t5] DEBUG com.demo.ReetLock - t5 print --&gt;5</span><br><span class="line">18:02:31.489 [t6] DEBUG com.demo.ReetLock - t6 print --&gt;6</span><br><span class="line">18:02:31.489 [t7] DEBUG com.demo.ReetLock - t7 print --&gt;7</span><br><span class="line">18:02:31.489 [t8] DEBUG com.demo.ReetLock - t8 print --&gt;8</span><br><span class="line">18:02:31.489 [t9] DEBUG com.demo.ReetLock - t9 print --&gt;9</span><br></pre></td></tr></table></figure>

<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><a href="#synchronized"></a>synchronized</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.demo;</span><br><span class="line"></span><br><span class="line">import com.google.common.collect.Lists;</span><br><span class="line">import lombok.SneakyThrows;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/** * @author tyb * @Description * @create 2022-09-27 10:51 */</span><br><span class="line">@Slf4j</span><br><span class="line">public class Sync &#123;</span><br><span class="line"></span><br><span class="line">    private static final int COUNT =10;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Thread&gt; threads = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o = new Object();</span><br><span class="line">        for (int i = 0; i &lt; COUNT; i++) &#123;</span><br><span class="line">            int finalI = i;</span><br><span class="line">            Thread thread = new Thread(()-&gt;&#123;                synchronized (o)&#123;                    log.debug(&quot;&#123;&#125; print --&gt;&#123;&#125;&quot;,Thread.currentThread().getName(), finalI);                &#125;            &#125;,&quot;t&quot;+i);            threads.add(thread);        &#125;        synchronized (o)&#123;            log.debug(&quot;main get lock &quot;);            for (int i = 0; i &lt; COUNT; i++) &#123;                threads.get(i).start();                TimeUnit.MICROSECONDS.sleep(50);            &#125;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">18:09:52.283 [main] DEBUG com.demo.Sync - main get lock </span><br><span class="line">18:09:52.301 [t9] DEBUG com.demo.Sync - t9 print --&gt;9</span><br><span class="line">18:09:52.304 [t8] DEBUG com.demo.Sync - t8 print --&gt;8</span><br><span class="line">18:09:52.304 [t7] DEBUG com.demo.Sync - t7 print --&gt;7</span><br><span class="line">18:09:52.304 [t6] DEBUG com.demo.Sync - t6 print --&gt;6</span><br><span class="line">18:09:52.304 [t5] DEBUG com.demo.Sync - t5 print --&gt;5</span><br><span class="line">18:09:52.304 [t4] DEBUG com.demo.Sync - t4 print --&gt;4</span><br><span class="line">18:09:52.304 [t3] DEBUG com.demo.Sync - t3 print --&gt;3</span><br><span class="line">18:09:52.304 [t2] DEBUG com.demo.Sync - t2 print --&gt;2</span><br><span class="line">18:09:52.304 [t1] DEBUG com.demo.Sync - t1 print --&gt;1</span><br><span class="line">18:09:52.304 [t0] DEBUG com.demo.Sync - t0 print --&gt;0</span><br></pre></td></tr></table></figure>

<p>可以看到，同样的逻辑synchronized与ReentrantLock输出是不同的。</p>
<p>那么ReentrantLock是公平锁还是非公平锁?如果ReentrantLock是公平锁是不是就是说synchronized是非公平锁呢?</p>
<h1 id="ReentrantLock-与synchronize"><a href="#ReentrantLock-与synchronize" class="headerlink" title="ReentrantLock 与synchronize"></a><a href="#reentrantlock-%E4%B8%8Esynchronize"></a>ReentrantLock 与synchronize</h1><p>ReentrantLock锁通过构造函数就可以指定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates an instance of &#123;@code ReentrantLock&#125;.</span><br><span class="line"> * This is equivalent to using &#123;@code ReentrantLock(false)&#125;.</span><br><span class="line"> */</span><br><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码以及注释可以看出，默认创建是非公平锁,只有指定参数false时（即：ReentrantLock(false)）才是公平锁。</p>
<p>那么疑问来了，</p>
<ul>
<li>既然是非公平锁，那为什么输出还是顺序的呢？</li>
<li>既然上面例子中输出顺序完全相反，是不是说synchronized是公平锁呢?</li>
</ul>
<p>其实不是这样的。看过之前synchronized介绍的文章，我们指定synchronized是通过系统pthread_mutex 实现了锁的互斥，本质上它是属于非公平锁。</p>
<h1 id="公平锁与非公平锁的区别"><a href="#公平锁与非公平锁的区别" class="headerlink" title="公平锁与非公平锁的区别"></a><a href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"></a>公平锁与非公平锁的区别</h1><ul>
<li>非公平锁加锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    final void lock() &#123;</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /**         * Performs non-fair tryLock.  tryAcquire is implemented in         * subclasses, but both need nonfair try for trylock method.         */</span><br><span class="line">    final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0) // overflow</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>公平锁加锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">            /**         * Fair version of tryAcquire.  Don&#x27;t grant access unless         * recursive call or no waiters or is first.         */</span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非公平锁上来就通过cas（此时不管队列是否有线程在等待） 修改状态，修改成功，那么就将主机改为拥有锁的线程;而公平锁会先看看是不是没有人持有锁（state&#x3D;0）并且还会看看有没有排队的线程，没有排队的线程，那么才执行CAS上锁</li>
<li>非公平锁第一次CAS失败后，在nonfairTryAcquire中会再次CAS尝试加锁；公平锁则没有这个过程。</li>
</ul>
<h1 id="AQS入队"><a href="#AQS入队" class="headerlink" title="AQS入队"></a><a href="#aqs%E5%85%A5%E9%98%9F"></a>AQS入队</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);                    p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);        &#125;    &#125;</span><br></pre></td></tr></table></figure>

<p>线程抢不到锁时，会调用acquireQueued(addWaiter(Node.EXCLUSIVE), arg))。</p>
<ol>
<li>addWaiter(Node.EXCLUSIVE), arg)将线程包装成一个Node节点。</li>
<li>再通过acquireQueued方法将Node节点加入到队列中。</li>
</ol>
<p>在acquireQueued时，如果前一个节点是head,那么会再一次尝试加锁。这是因为，如果前一个节点是head的话，那么在当前线程来加锁的过程中，head可能会完成加锁业务后释放锁，这样就不需要阻塞当前线程</p>
<p>不管公平锁还是非公平锁，它们都被封装成Node,然后放入AQS的等待队列中。一旦加入队列，那么就排队等待被唤醒</p>
<h2 id="Node的主要结构"><a href="#Node的主要结构" class="headerlink" title="Node的主要结构"></a><a href="#node%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84"></a>Node的主要结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;        //等待状态。-1时需要叫醒下一个等待节点</span><br><span class="line">        volatile int waitStatus;</span><br><span class="line"></span><br><span class="line">        //等待队列中的前一个节点</span><br><span class="line">        volatile Node prev;</span><br><span class="line"></span><br><span class="line">        //等待队列中的下一个节点</span><br><span class="line">        volatile Node next;</span><br><span class="line"></span><br><span class="line">        //等待队列中的线程</span><br><span class="line">        volatile Thread thread;</span><br><span class="line"></span><br><span class="line">        //指向condition中的等待的节点或者特定Shared node        </span><br><span class="line">        Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>node节点的结构中，有个waitStatus状态值。它表示等待状态。它有几个值：</p>
<ul>
<li>1表示被取消；</li>
<li>0 默认（Int的默认值）</li>
<li>1 表示需要唤醒下一个节点</li>
<li>-2 表示在Condition中等待。在ReentrantLock中，可以通过它来做条件等待，类似synchronized中的wait。</li>
<li>-3 指示下一个 acquireShared 应该无条件传播</li>
</ul>
<p>上面介绍说通过acquireQueued(addWaiter(Node.EXCLUSIVE), arg))加入队列。在加入队列是，新封装的Node节点的waitStatus值是int类型的默认值0。但是按照JUC中的说明，waitStatus只有是-1的时候才是唤醒状态。那么谁负责唤醒它呢?或者说，如果有新的node节点加入到队列，它是怎样唤醒其他节点的呢？</p>
<p>看看加入队列的 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);                    p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);        &#125;    &#125;</span><br></pre></td></tr></table></figure>

<p>在shouldParkAfterFailedAcquire中，会将waitStatus修改为-1.代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">       int ws = pred.waitStatus;</span><br><span class="line">       if (ws == Node.SIGNAL)</span><br><span class="line">           /*</span><br><span class="line">            * This node has already set status asking a release</span><br><span class="line">            * to signal it, so it can safely park.</span><br><span class="line">            */</span><br><span class="line">           return true;</span><br><span class="line">       if (ws &gt; 0) &#123;</span><br><span class="line">           /*</span><br><span class="line">            * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">            * indicate retry.</span><br><span class="line">            */</span><br><span class="line">           do &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">           pred.next = node;        &#125; else &#123;</span><br><span class="line">           /*</span><br><span class="line">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">            * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="line">            * retry to make sure it cannot acquire before parking.</span><br><span class="line">            */</span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个地方是将要排队的线程封装成Node入队后，将Node的前一个waitStatus改成-1,而当前节点的waitStatus仍然是0,也就是说它不需要唤醒其他节点。 这个是因为，在AQS队列中，是按照线程先后顺序排队的。排在最后的一个线程肯定不要唤醒其他线程</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#%E6%80%BB%E7%BB%93"></a>总结</h1><p>相同点： 不管是公平锁还是非公平锁，它们的区别主要在加锁的时候。如果一旦进入到等待队列，就会在队列中等待被唤醒。 ReentrantLock 中的队列是FIFO，synchronized则是LIFO模式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/10/29/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/10/29/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%B5%85%E6%9E%90/" class="post-title-link" itemprop="url">volatile关键字浅析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-29 11:23:06 / Modified: 15:10:26" itemprop="dateCreated datePublished" datetime="2022-10-29T11:23:06+08:00">2022-10-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>volatile 是Java语音提供的一种非常非常轻量级的同步机制。在JDK的源码中，被大量使用。本文将大致介绍volatile底层实现机制。通常用在一个线程写入，而其他线程读取的场景。</p>
<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>CPU设计了L1、L2等缓存用来屏蔽CPU运算速度与内存读写上的差异。是同时，CPU为了提升运行速度，对一些指令做了重排序。比如有如下代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">int b = 0;</span><br><span class="line">a = 10;</span><br></pre></td></tr></table></figure>

<p>CPU 在运算上述代码比如a&#x3D;0时，需要先load a,然后将0赋值给a后，再将a写回去（写到缓存或者内存上）。如果CPU将a&#x3D;10放到b&#x3D;0之前，那么可以省掉再次load等操作。</p>
<p>Java语言中，为了充分利用CPU的高性能，又能屏蔽各种CPU以及JVM 之间的差异，从而定义了JMM的规范。</p>
<p>在JMM规范中，volatile 通过内存屏障的方式实现了轻量级的同步机制。具体来说，就是storeload屏障。</p>
<h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><h2 id="JVM级别的指令"><a href="#JVM级别的指令" class="headerlink" title="JVM级别的指令"></a>JVM级别的指令</h2><p>首先，来看一段简单的代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.syn;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author tyb</span><br><span class="line"> * @Description</span><br><span class="line"> * @create 2022-10-26 10:52</span><br><span class="line"> */</span><br><span class="line">public class VolatileTest &#123;</span><br><span class="line">    static int a = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        a = 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有人会说，通过javap -c查看JVM指令是不是就可以看出端倪了呢？</p>
<p>没有volatile关键字的场景下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c VolatileTest.class</span><br><span class="line">Compiled from &quot;VolatileTest.java&quot;</span><br><span class="line">public class com.syn.VolatileTest &#123;</span><br><span class="line">  static int a;</span><br><span class="line"></span><br><span class="line">  public com.syn.VolatileTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        10</span><br><span class="line">       2: putstatic     #2                  // Field a:I</span><br><span class="line">       5: return</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: putstatic     #2                  // Field a:I</span><br><span class="line">       4: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有volatile关键字的场景下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c VolatileTest.class</span><br><span class="line">Compiled from &quot;VolatileTest.java&quot;</span><br><span class="line">public class com.syn.VolatileTest &#123;</span><br><span class="line">  static volatile int a;</span><br><span class="line"></span><br><span class="line">  public com.syn.VolatileTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        10</span><br><span class="line">       2: putstatic     #2                  // Field a:I</span><br><span class="line">       5: return</span><br><span class="line"></span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       0: iconst_0</span><br><span class="line">       1: putstatic     #2                  // Field a:I</span><br><span class="line">       4: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面2次的JVM级别的指令中，完全是一直的。</p>
<p>实际上，我们需要通过hsdis查看生产的汇编代码。</p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><p>要查看Java的汇编指令，我们需要通过工具hsdis.dll(windows 环境)。 可以下载一个hsdis-amd64.dll放置JAVA_HOME下的\jre\bin\server目录中。 在jvm 参数中指定如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xcomp</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+PrintAssembly</span><br><span class="line">-XX:CompileCommand=compileonly,*VolatileTest.main</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明：参数 -Xcomp 是让虚拟机以编译模式执行代码，这样代码可以偷懒，不需要执行足够次数来预热都能触发 JIT 编译。两个 -XX:CompileCommand 意思是让编译器仅仅编译，-XX:+PrintAssembly 就是输出反汇编内容</p>
</blockquote>
<p>在输出中，我们可找到lock addl相关的输出（截取部分）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x000000000384c1a8: sub    $0x30,%rsp         ;*bipush</span><br><span class="line">                                                ; - com.syn.VolatileTest::main@0 (line 12)</span><br><span class="line"></span><br><span class="line">  0x000000000384c1ac: movabs $0x7162a06e8,%rsi  ;   &#123;oop(a &#x27;java/lang/Class&#x27; = &#x27;com/syn/VolatileTest&#x27;)&#125;</span><br><span class="line">  0x000000000384c1b6: mov    $0xa,%edi</span><br><span class="line">  0x000000000384c1bb: mov    %edi,0x68(%rsi)</span><br><span class="line">  0x000000000384c1be: lock addl $0x0,(%rsp)     ;*putstatic a</span><br><span class="line">                                                ; - com.syn.VolatileTest::main@2 (line 12)可以用JIT工具查看，可视化效果更好</span><br></pre></td></tr></table></figure>

<p>用JIT工具查看如图：</p>
<p><img src="/blogs/images/volatile.png"></p>
<h1 id="JVM实现-与storeload"><a href="#JVM实现-与storeload" class="headerlink" title="JVM实现 与storeload"></a>JVM实现 与storeload</h1><p>在查看Java的汇编指令之前，有一点需要指出的是：在Java中，对static变量的操作是通过pustatic来完成的。</p>
<h2 id="putstatic"><a href="#putstatic" class="headerlink" title="putstatic"></a>putstatic</h2><h3 id="Operation"><a href="#Operation" class="headerlink" title="Operation"></a>Operation</h3><p>Set static field in class</p>
<p>感兴趣的同学可以参见官方文档：<a href="https://link.zhihu.com/?target=https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html%23jvms-6.5.putstatic">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.putstatic</a></p>
<p>在JVM 的字节码解析器bytecodeInterpreter.cpp文件中，我们看到对putstatic的处理：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CASE(_putstatic):</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line">if (cache-&gt;is_volatile()) &#123;</span><br><span class="line">            if (tos_type == itos) &#123;</span><br><span class="line">              obj-&gt;release_int_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">            &#125; else if (tos_type == atos) &#123;</span><br><span class="line">              VERIFY_OOP(STACK_OBJECT(-1));</span><br><span class="line">              obj-&gt;release_obj_field_put(field_offset, STACK_OBJECT(-1));</span><br><span class="line">            &#125; else if (tos_type == btos) &#123;</span><br><span class="line">              obj-&gt;release_byte_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">            &#125; else if (tos_type == ztos) &#123;</span><br><span class="line">              int bool_field = STACK_INT(-1);  // only store LSB</span><br><span class="line">              obj-&gt;release_byte_field_put(field_offset, (bool_field &amp; 1));</span><br><span class="line">            &#125; else if (tos_type == ltos) &#123;</span><br><span class="line">              obj-&gt;release_long_field_put(field_offset, STACK_LONG(-1));</span><br><span class="line">            &#125; else if (tos_type == ctos) &#123;</span><br><span class="line">              obj-&gt;release_char_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">            &#125; else if (tos_type == stos) &#123;</span><br><span class="line">              obj-&gt;release_short_field_put(field_offset, STACK_INT(-1));</span><br><span class="line">            &#125; else if (tos_type == ftos) &#123;</span><br><span class="line">              obj-&gt;release_float_field_put(field_offset, STACK_FLOAT(-1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              obj-&gt;release_double_field_put(field_offset, STACK_DOUBLE(-1));</span><br><span class="line">            &#125;</span><br><span class="line">            OrderAccess::storeload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过cache-&gt;is_volatile()可以看到如果变量被volatile修饰，那么最后会通过OrderAccess::storeload()来处理。</p>
<p>OrderAccess有很多种不同平台上的实现。看下Linux上的实现：</p>
<p>在Linux的orderAccess_linux_x86.hpp文件中：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">inline void OrderAccess::storeload()  &#123; fence();            &#125;</span><br><span class="line"></span><br><span class="line">inline void OrderAccess::fence() &#123;</span><br><span class="line">   // always use locked addl since mfence is sometimes expensive</span><br><span class="line">#ifdef AMD64</span><br><span class="line">  __asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">#else</span><br><span class="line">  __asm__ volatile (&quot;lock; addl $0,0(%%esp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">#endif</span><br><span class="line">  compiler_barrier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Windows下（orderAccess_windows_x86.hpp文件中）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inline void OrderAccess::storeload()  &#123; fence(); &#125;</span><br><span class="line"></span><br><span class="line">inline void OrderAccess::acquire()    &#123; compiler_barrier(); &#125;</span><br><span class="line">inline void OrderAccess::release()    &#123; compiler_barrier(); &#125;</span><br><span class="line"></span><br><span class="line">inline void OrderAccess::fence() &#123;</span><br><span class="line">#ifdef AMD64</span><br><span class="line">  StubRoutines_fence();</span><br><span class="line">#else</span><br><span class="line">  __asm &#123;</span><br><span class="line">    lock add dword ptr [esp], 0;</span><br><span class="line">  &#125;</span><br><span class="line">#endif // AMD64</span><br><span class="line">  compiler_barrier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上可以看到，通过汇编级别的指令，通过lock addl操作 锁住总线的方式实现内存屏障。</p>
<blockquote>
<p>在IA32 手册5.20 SYSTEM INSTRUCTIONS 部分，lock LOCK (prefix) Lock Bus. 下载地址：<a href="https://link.zhihu.com/?target=https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html">https://www.intel.cn/content/www/cn/zh/architecture-and-technology/64-ia-32-architectures-software-developer-vol-1-manual.html</a></p>
</blockquote>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ul>
<li>volatile实现通过锁总线的方式实现同步。但volatile只是一种轻量的同步机制。</li>
<li>虽然volatile可以实现轻量级的同步机制，但是由于对volatitle修饰的变量的操作不是原子的，所以它不能保证原子性</li>
</ul>
<p>参考：</p>
<p> <a target="_blank" rel="noopener" href="https://www.infoq.cn/article/zzm-java-hsdis-jvm">JVM执行篇：使用HSDIS插件分析JVM代码执行细节_Java_周志明_InfoQ精选文章</a></p>
<p>JIT 工具 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/stevenczp/p/7975776.html">如何在windows平台下使用hsdis与jitwatch查看JIT后的汇编码 - stevenczp - 博客园</a> <a target="_blank" rel="noopener" href="https://github.com/AdoptOpenJDK/jitwatch">GitHub - AdoptOpenJDK&#x2F;jitwatch: Log analyser &#x2F; visualiser for Java HotSpot JIT compiler. Inspect inlining decisions, hot methods, bytecode, and assembly. View results in the JavaFX user interface.</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/10/18/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/10/18/%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD/" class="post-title-link" itemprop="url">thread-interrupt</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-10-18 16:14:52 / Modified: 16:21:18" itemprop="dateCreated datePublished" datetime="2022-10-18T16:14:52+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>线程的stop等方法都被废弃了。在一些场景下，我们可以通过让线程中断的方式结束掉线程。</p>
<p>首先抛出2个问题：</p>
<ol>
<li>synchronized加锁的线程可以被中断吗？</li>
<li>ReentrantLock加锁可以被中断吗？</li>
</ol>
<p>回答上面的问题，先看看2个小示例：</p>
<h2 id="synchronized加锁是否可以中断"><a href="#synchronized加锁是否可以中断" class="headerlink" title="synchronized加锁是否可以中断"></a><a href="#synchronized%E5%8A%A0%E9%94%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%AD%E6%96%AD"></a>synchronized加锁是否可以中断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** * @author javaer * @Description * @create 2022-09-28 10:56 */</span><br><span class="line">@Slf4j</span><br><span class="line">public class SyncInterrupt &#123;</span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object o = new Object();</span><br><span class="line"></span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;            synchronized (o) &#123;                log.debug(&quot;thread start ~~&quot;);                while (Thread.currentThread().isInterrupted()) &#123;                    break;                &#125;            &#125;            log.debug(&quot;thread over~&quot;);        &#125;, &quot;t1&quot;);        t1.start();        synchronized (o) &#123;            Thread.sleep(1000);            log.debug(&quot;main  interrupt t1 thread&quot;);            t1.interrupt();            t1.join();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18:26:34.169 [main] DEBUG com.demo.SyncInterrupt - main  interrupt t1 thread</span><br></pre></td></tr></table></figure>

<p>这说明主线程抢占锁后，中断t1线程并等待t1执行完毕。t1无法响应中断</p>
<h2 id="ReentrantLock加锁是否可以中断"><a href="#ReentrantLock加锁是否可以中断" class="headerlink" title="ReentrantLock加锁是否可以中断"></a><a href="#reentrantlock%E5%8A%A0%E9%94%81%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%B8%AD%E6%96%AD"></a>ReentrantLock加锁是否可以中断</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * @author javaer</span><br><span class="line"> * @Description</span><br><span class="line"> * @create 2022-09-28 18:28</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class ReetInterrupt &#123;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock = new ReentrantLock();</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;            try &#123;                lock.lock();                log.debug(&quot;thread start ~~&quot;);                while (Thread.currentThread().isInterrupted()) &#123;                    break;                &#125;                log.debug(&quot;thread over~&quot;);            &#125;  finally &#123;                lock.unlock();            &#125;        &#125;, &quot;t1&quot;);        t1.start();        lock.lock();        try &#123;            Thread.sleep(1000);            log.debug(&quot;main  interrupt t1 thread&quot;);            t1.interrupt();            t1.join();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18:35:25.735 [main] DEBUG com.demo.ReetInterrupt - main  interrupt t1 thread</span><br></pre></td></tr></table></figure>

<p>说明ReentrantLock.lock 方法不支持打断。如果要打断，应该使用lockInterruptibly方法。</p>
<p>将上面demo 改造以下，通过lockInterruptibly方法加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** * @author javaer * @Description * @create 2022-09-28 18:28 */</span><br><span class="line">@Slf4j</span><br><span class="line">public class ReetInterrupt &#123;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock = new ReentrantLock();</span><br><span class="line">        Thread t1 = new Thread(() -&gt; &#123;            try &#123;                lock.lockInterruptibly();                log.debug(&quot;thread start ~~&quot;);                while (Thread.currentThread().isInterrupted()) &#123;                    break;                &#125;                log.debug(&quot;thread over~&quot;);            &#125; catch (InterruptedException e) &#123;                log.error(&quot;exception :&quot;, e);            &#125; finally &#123;                lock.unlock();            &#125;        &#125;, &quot;t1&quot;);        t1.start();        lock.lock();        try &#123;            Thread.sleep(1000);            log.debug(&quot;main  interrupt t1 thread&quot;);            t1.interrupt();            t1.join();        &#125; finally &#123;            lock.unlock();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">18:36:49.028 [main] DEBUG com.demo.ReetInterrupt - main  interrupt t1 thread</span><br><span class="line">18:36:49.031 [t1] ERROR com.demo.ReetInterrupt - exception :</span><br><span class="line">java.lang.InterruptedException: null</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)</span><br><span class="line">    at com.demo.ReetInterrupt.lambda$main$0(ReetInterrupt.java:21)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Exception in thread &quot;t1&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">    at com.demo.ReetInterrupt.lambda$main$0(ReetInterrupt.java:30)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在非登场场景下，如ReentrantLock\synchronized 已经进入到临界区内，那么也是也响应的</p>
</blockquote>
<h1 id="JDK相关API"><a href="#JDK相关API" class="headerlink" title="JDK相关API"></a><a href="#jdk%E7%9B%B8%E5%85%B3api"></a>JDK相关API</h1><ul>
<li>Thread.interrupted() 判断线程是否被打断。它会清楚线程的打断状态</li>
<li>interrupt 打断线程</li>
<li>isInterrupted 返回线程的打断状态</li>
</ul>
<p>看看如下代码输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class Interrupted &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">        log.debug(&quot;Thread.interrupted result--: &quot;+Thread.interrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line">        System.out.println(Thread.currentThread().isInterrupted());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">18:42:45.026 [main] DEBUG com.demo.Interrupted - Thread.interrupted result--: true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<p>通过interrupt打断后，在通过log.debug中调用interrupted后，线程打断状态输出的是false</p>
<p>总结： 如果想打断线程，最好使用ReentrantLock的lockInterruptibly方法。在等锁状态下ReentrantLock与synchronized 都不可被打断。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/08/29/synchronized%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/08/29/synchronized%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4/" class="post-title-link" itemprop="url">synchronized与对象头</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-29 21:20:58" itemprop="dateCreated datePublished" datetime="2022-08-29T21:20:58+08:00">2022-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-18 16:22:26" itemprop="dateModified" datetime="2022-10-18T16:22:26+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>引叙： Java里通过AQS实现的锁，在加锁时通过设置state 变量值就能实现上锁。但是synchronized内置锁，它是不是也和AQS 类似会修改变量值呢?如果修改的话，它又是修改了对象什么东西?</p>
<p>先给出结论： synchronized上锁时，会修改对象头。</p>
<h1 id="OpenJdk关于对象头与锁状态的说明（MarkOop-hpp）"><a href="#OpenJdk关于对象头与锁状态的说明（MarkOop-hpp）" class="headerlink" title="OpenJdk关于对象头与锁状态的说明（MarkOop.hpp）"></a><a href="#openjdk%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%8E%E9%94%81%E7%8A%B6%E6%80%81%E7%9A%84%E8%AF%B4%E6%98%8Emarkoophpp"></a>OpenJdk关于对象头与锁状态的说明（MarkOop.hpp）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span><br><span class="line">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span><br><span class="line">//</span><br><span class="line">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span><br><span class="line">//</span><br><span class="line">//    [ptr             | 00]  locked             ptr points to real header on stack</span><br><span class="line">//    [header      | 0 | 01]  unlocked           regular object header</span><br><span class="line">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span><br><span class="line">//    [ptr             | 11]  marked             used by markSweep to mark an object</span><br><span class="line">//                                               not valid at any other time</span><br></pre></td></tr></table></figure>

<p>通过MarkOop中的注释，可以知道在JVM得出如下结论：</p>
<ul>
<li>synchronized有偏向锁，轻量锁、重量锁之分</li>
<li>101为 偏向锁。偏向锁还有2种情况：一个是匿名偏向，一个是偏向某个线程</li>
<li>00 已经上锁后的状态，它指向线程栈中真是的对象头</li>
<li>01 无锁</li>
<li>10 重量锁。后面的注释意思是膨胀后的锁，这是因为发生了资源竞争，导致synchronized发生膨胀。</li>
</ul>
<h1 id="验证synchronized对对象头的修改"><a href="#验证synchronized对对象头的修改" class="headerlink" title="验证synchronized对对象头的修改"></a><a href="#%E9%AA%8C%E8%AF%81synchronized%E5%AF%B9%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E4%BF%AE%E6%94%B9"></a>验证synchronized对对象头的修改</h1><p>先通过synchronized的使用看看对对象头的操作，在示例中，先直接打印对象头然后与加锁后对象头比较一下，看区别在哪</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class ObjectHeader &#123;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Person person = new Person();</span><br><span class="line">        log.debug(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line">        final Thread thread = new Thread(() -&gt; &#123;            synchronized (person)&#123;                log.debug(&quot;加锁后===========&quot;);                log.debug(ClassLayout.parseInstance(person).toPrintable());            &#125;        &#125;);        thread.start();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">17:39:19.720 [main] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">17:39:19.726 [Thread-1] DEBUG com.thread.ObjectHeader - 加锁后===========</span><br><span class="line">17:39:19.728 [Thread-1] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000700010d1b908 (thin lock: 0x0000700010d1b908)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>从上面2次打印的对象头可以看到对象头确实是不一样了。</p>
<p>但你有发现有什么问题没有呢？是不是和上面MarkOop里定义的有点不一样？ 可能有人会说哪里不一样？ 其实仔细观察上面2次打印的对象头，确实发现了这样2个问题：</p>
<ol>
<li>锁状态是不可偏向的（后面打印信息是non-biasable，意思就锁不可偏向）</li>
<li>synchronized加锁后，直接成了轻量锁（注意到加锁后，thin lock了吗？）</li>
</ol>
<p>为什么？这是因为JVM中存在偏向延迟</p>
<h1 id="什么是偏向延迟"><a href="#什么是偏向延迟" class="headerlink" title="什么是偏向延迟"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%8F%E5%90%91%E5%BB%B6%E8%BF%9F"></a>什么是偏向延迟</h1><p>JVM自身代码中也会用到synchronized。JVM认为自己的锁是不会存在偏向锁的，所以直接改成了轻量级锁。在JVM启动完成后，用户自己使用synchronized可以采用偏向锁模式。 JVM为什么要这样做呢？因为这样可以避免判断是否是偏向锁的逻辑，直接用轻量锁上锁。</p>
<h1 id="JVM偏向延迟是多久呢"><a href="#JVM偏向延迟是多久呢" class="headerlink" title="JVM偏向延迟是多久呢"></a><a href="#jvm%E5%81%8F%E5%90%91%E5%BB%B6%E8%BF%9F%E6%98%AF%E5%A4%9A%E4%B9%85%E5%91%A2"></a>JVM偏向延迟是多久呢</h1><p>JVM默认的偏向延迟是4秒钟。可以通过如下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version  | grep Delay</span><br><span class="line">     intx BiasedLockingStartupDelay                 = 4000                                &#123;product&#125;</span><br><span class="line">     bool LIRFillDelaySlots                         = false                               &#123;C1 pd product&#125;</span><br><span class="line">     intx SafepointTimeoutDelay                     = 10000                               &#123;product&#125;</span><br><span class="line">     intx SuspendRetryDelay                         = 5                                   &#123;product&#125;</span><br><span class="line">     intx Tier3DelayOff                             = 2                                   &#123;product&#125;</span><br><span class="line">     intx Tier3DelayOn                              = 5                                   &#123;product&#125;</span><br><span class="line">openjdk version &quot;1.8.0_312&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_312-b07)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode)</span><br></pre></td></tr></table></figure>

<p>4秒钟之后，我们定义的对象就可使用偏向锁。</p>
<p>修改代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class ObjectHeader &#123;</span><br><span class="line"></span><br><span class="line">    @SneakyThrows</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(5);</span><br><span class="line">        Person person = new Person();</span><br><span class="line">        log.debug(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line">        final Thread thread = new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (person)&#123;</span><br><span class="line">                log.debug(&quot;加锁后===========&quot;);</span><br><span class="line">                log.debug(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        log.debug(&quot;释放锁后===========&quot;);</span><br><span class="line">        log.debug(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">18:32:17.985 [main] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">18:32:17.988 [Thread-1] DEBUG com.thread.ObjectHeader - 加锁后===========</span><br><span class="line">18:32:17.989 [Thread-1] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x00007fcd4e393805 (biased: 0x0000001ff3538e4e; epoch: 0; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">18:32:17.989 [main] DEBUG com.thread.ObjectHeader - 释放锁后===========</span><br><span class="line">18:32:17.990 [main] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x00007fcd4e393805 (biased: 0x0000001ff3538e4e; epoch: 0; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>上面输出中2个都是偏向锁，是因为过了JVM偏向延迟时间后，对象可以使用偏向锁，但是没有线程加锁所以锁10。也就是MarkOop中说到的匿名偏向。在synchronized中，因为已经上锁了，所以还是101。此时输出的数据0x0000001ff625c58c中，包含偏向的线程ID等信息。</p>
<blockquote>
<p>也通过-XX:BiasedLockingStartupDelay&#x3D;0关闭偏向延迟</p>
</blockquote>
<p>还有一点需要注意的是，即使释放锁后对象头打印的也没有改变。是因为偏向锁如果下次再来加锁，直接比较对象头就行了，CAS也不需要了。这样的效率是最高的。如果此时对象头还原成了匿名锁对象头一样，那下次线程再来加锁，还需要进行CAS操作。</p>
<h1 id="重量锁的对象头"><a href="#重量锁的对象头" class="headerlink" title="重量锁的对象头"></a><a href="#%E9%87%8D%E9%87%8F%E9%94%81%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"></a>重量锁的对象头</h1><p>首先修改代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@SneakyThrows</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    log.debug(ClassLayout.parseInstance(person).toPrintable());</span><br><span class="line">    final Thread thread = new Thread(() -&gt; &#123;            synchronized (person)&#123;                log.debug(&quot;加锁后===========&quot;);                log.debug(ClassLayout.parseInstance(person).toPrintable());            &#125;        &#125;);        thread.start();        //thread.join();        synchronized (person)&#123;            log.debug(&quot;main 线程加锁成功===========&quot;);            log.debug(ClassLayout.parseInstance(person).toPrintable());        &#125;    &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">18:39:54.432 [main] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000005 (biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">18:39:54.435 [main] DEBUG com.thread.ObjectHeader - main 线程加锁成功===========</span><br><span class="line">18:39:54.436 [main] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x00007f8826814dda (fat lock: 0x00007f8826814dda)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">18:39:54.436 [Thread-1] DEBUG com.thread.ObjectHeader - 加锁后===========</span><br><span class="line">18:39:54.437 [Thread-1] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x00007f8826814dda (fat lock: 0x00007f8826814dda)</span><br><span class="line">  8   4        (object header: class)    0xf800dd95</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>这样只看到成了fat lock。将jol修改成0.10版本后，再看下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">18:42:41.120 [main] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           95 dd 00 f8 (10010101 11011101 00000000 11111000) (-134161003)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">18:42:41.123 [main] DEBUG com.thread.ObjectHeader - main 线程加锁成功===========</span><br><span class="line">18:42:41.124 [main] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           ea f5 01 6f (11101010 11110101 00000001 01101111) (1862399466)</span><br><span class="line">      4     4        (object header)                           c5 7f 00 00 (11000101 01111111 00000000 00000000) (32709)</span><br><span class="line">      8     4        (object header)                           95 dd 00 f8 (10010101 11011101 00000000 11111000) (-134161003)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br><span class="line"></span><br><span class="line">18:42:41.124 [Thread-1] DEBUG com.thread.ObjectHeader - 加锁后===========</span><br><span class="line">18:42:41.125 [Thread-1] DEBUG com.thread.ObjectHeader - com.thread.Person object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           ea f5 01 6f (11101010 11110101 00000001 01101111) (1862399466)</span><br><span class="line">      4     4        (object header)                           c5 7f 00 00 (11000101 01111111 00000000 00000000) (32709)</span><br><span class="line">      8     4        (object header)                           95 dd 00 f8 (10010101 11011101 00000000 11111000) (-134161003)</span><br><span class="line">     12     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看见，输出中的ea对应的二进制11101010的最后2位确实是10</p>
<p>以ea对应的二进制11101010中进行说明：</p>
<ul>
<li>第一个0未使用，</li>
<li>后面4个0代表对象分代年龄</li>
<li>后一个0 代表是否可以偏向</li>
<li>最后2位代表是否有锁</li>
</ul>
<p>此致，所有锁对应的对象头验证完毕。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><a href="#%E7%BB%93%E8%AE%BA"></a>结论</h1><p>synchronized 加锁时修改了对象头中的信息。synchronized锁分为偏向锁、轻量锁、重量锁3种类别。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/08/29/Netty%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B9%8Bprotobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/08/29/Netty%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E4%B9%8Bprotobuf/" class="post-title-link" itemprop="url">Netty中的序列化方式之protobuf</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-29 20:45:01" itemprop="dateCreated datePublished" datetime="2022-08-29T20:45:01+08:00">2022-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-18 11:13:37" itemprop="dateModified" datetime="2022-10-18T11:13:37+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Netty/" itemprop="url" rel="index"><span itemprop="name">Netty</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="为什么要做序列化"><a href="#为什么要做序列化" class="headerlink" title="为什么要做序列化"></a>为什么要做序列化</h3><p>    在网络通讯中，数据以二进制形式进行传输。假设在我们网络通讯业务中，客户端需要将Person对象传到服务端进行处理，如何传输呢？总不能直接发送Person对象实例吧？因此需要将Person对象实例经过序列化后进行传输。</p>
<h3 id="序列化的方式有哪些"><a href="#序列化的方式有哪些" class="headerlink" title="序列化的方式有哪些"></a>序列化的方式有哪些</h3><p>    在Java应用程序中，可以通过实现Serializable接口申明类可以进行序列化。常用的序列化的方式有xml、JSON、Protobuf、avro等。这几种序列化的方式优缺点如下：</p>
<ul>
<li><p>XML格式中定义多个对象存在大量重复的Scheme定义，对高效的传输而言，无疑增加了网络传输的开销。</p>
</li>
<li><p>JSON是一种比较通用给的格式。能支持在不通语言中消息格式定义。传输数量比XML少很多</p>
</li>
<li><p>Protobuf是Google开源的一种开源、跨平台的用于做数据结果序列化的工具。效率比上面几种要优</p>
</li>
<li><p>avro 在大数据中应用比较多</p>
</li>
</ul>
<h3 id="Netty-中使用protobuf序列化消息"><a href="#Netty-中使用protobuf序列化消息" class="headerlink" title="Netty 中使用protobuf序列化消息"></a>Netty 中使用protobuf序列化消息</h3><h4 id="step1-定义pb格式"><a href="#step1-定义pb格式" class="headerlink" title="step1 :定义pb格式"></a>step1 :定义pb格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">option java_package = &quot;com.serilizer.pb&quot;;</span><br><span class="line">option java_outer_classname = &quot;PersonProto&quot;;</span><br><span class="line"></span><br><span class="line">message PersonProtoBean &#123;</span><br><span class="line">string name = 1;</span><br><span class="line">int32 age = 2;</span><br><span class="line">string address = 3 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="step2-将pb生成Java文件代码"><a href="#step2-将pb生成Java文件代码" class="headerlink" title="step2 : 将pb生成Java文件代码"></a>step2 : 将pb生成Java文件代码</h4><p>通过如下命令，用pb定义的格式，将其生成Java类（事先需要安装protobuf）。</p>
<p>protoc 需要3个参数：</p>
<ul>
<li><p>第1个参数： 指定pb 文件所在的文件夹</p>
</li>
<li><p>第2个参数：指定需要将Java类文件生成到哪个路径下</p>
</li>
<li><p>第3个参数：指pb文件名字</p>
</li>
</ul>
<blockquote>
<p>注意，这个地方的路径需要根据pb文件的路径以及需要将Java文件生成在哪个地方来定义。本示例仅仅是示例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I=.   --java_out=../../    person.pb</span><br></pre></td></tr></table></figure>

<p>然后就可以使用pb在Netty客户端与服务端之间传输了。示例如下。</p>
<h4 id="服务端使用："><a href="#服务端使用：" class="headerlink" title="服务端使用："></a>服务端使用：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line">        ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(Channel channel) throws Exception &#123;</span><br><span class="line">                        /*去掉消息长度部分，并且根据消息长度读取实际数据*/</span><br><span class="line">                        channel.pipeline().addLast(new ProtobufVarint32FrameDecoder());</span><br><span class="line">                        channel.pipeline().addLast(new ProtobufDecoder(PersonProto.PersonProtoBean.getDefaultInstance()));</span><br><span class="line">                        channel.pipeline().addLast(new ServerHandler()) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        final ChannelFuture channelFuture = bootstrap.bind(9999);</span><br><span class="line">        log.info(&quot;server started&quot;);</span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServerHandler的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.serilizer;</span><br><span class="line"></span><br><span class="line">import com.serilizer.pb.PersonProto;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author tyb</span><br><span class="line"> * @Description</span><br><span class="line"> * @create 2022-05-05 20:35</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class ServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        PersonProto.PersonProtoBean personProtoBean = (PersonProto.PersonProtoBean)msg;</span><br><span class="line">        log.info(&quot;server received :[&#123;&#125;]&quot;, personProtoBean.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.serilizer;</span><br><span class="line"></span><br><span class="line">import io.netty.bootstrap.Bootstrap;</span><br><span class="line">import io.netty.channel.Channel;</span><br><span class="line">import io.netty.channel.ChannelFuture;</span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.EventLoopGroup;</span><br><span class="line">import io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line">import io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line">import io.netty.handler.codec.protobuf.ProtobufEncoder;</span><br><span class="line">import io.netty.handler.codec.protobuf.ProtobufVarint32LengthFieldPrepender;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author tyb</span><br><span class="line"> * @Description</span><br><span class="line"> * @create 2022-05-05 20:43</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = new Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(Channel channel) throws Exception &#123;</span><br><span class="line">                        /* 解决半包粘包问题*/</span><br><span class="line">                        channel.pipeline().addLast(new ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">                        /* 序列化*/</span><br><span class="line">                        channel.pipeline().addLast(new ProtobufEncoder());</span><br><span class="line">                        /* 实际业务处理*/</span><br><span class="line">                        channel.pipeline().addLast(new ClientHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        final ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 9999);</span><br><span class="line">        channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClientHandler实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.serilizer;</span><br><span class="line"></span><br><span class="line">import com.serilizer.pb.PersonProto;</span><br><span class="line">import io.netty.buffer.ByteBuf;</span><br><span class="line">import io.netty.buffer.Unpooled;</span><br><span class="line">import io.netty.channel.ChannelHandler;</span><br><span class="line">import io.netty.channel.ChannelHandlerContext;</span><br><span class="line">import io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line">import io.netty.util.CharsetUtil;</span><br><span class="line">import io.netty.util.concurrent.EventExecutorGroup;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author tyb</span><br><span class="line"> * @Description</span><br><span class="line"> * @create 2022-05-05 20:44</span><br><span class="line"> */</span><br><span class="line">@Slf4j</span><br><span class="line">public class ClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        final PersonProto.PersonProtoBean.Builder builder = PersonProto.PersonProtoBean.newBuilder();</span><br><span class="line">        builder.setName(&quot;tao&quot;);</span><br><span class="line">        builder.setAge(36);</span><br><span class="line">        builder.setAddress(&quot;wuhan&quot;);</span><br><span class="line">        ctx.writeAndFlush(builder.build());</span><br><span class="line">        log.info(&quot;sent over~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        log.error(&quot;exception occur&quot;,cause.getCause());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception &#123;</span><br><span class="line">        log.info(&quot;client received ：【&#123;&#125;】&quot;,byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">21:26:56.068 [nioEventLoopGroup-2-1] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.linkCapacity: 16</span><br><span class="line">21:26:56.068 [nioEventLoopGroup-2-1] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.ratio: 8</span><br><span class="line">21:26:56.075 [nioEventLoopGroup-2-1] INFO com.serilizer.ClientHandler - sent over~</span><br></pre></td></tr></table></figure>

<p>服务端输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">21:26:49.836 [main] INFO com.serilizer.Server - server started</span><br><span class="line">21:26:56.077 [nioEventLoopGroup-2-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.maxCapacityPerThread: 4096</span><br><span class="line">21:26:56.077 [nioEventLoopGroup-2-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.maxSharedCapacityFactor: 2</span><br><span class="line">21:26:56.077 [nioEventLoopGroup-2-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.linkCapacity: 16</span><br><span class="line">21:26:56.077 [nioEventLoopGroup-2-2] DEBUG io.netty.util.Recycler - -Dio.netty.recycler.ratio: 8</span><br><span class="line">21:26:56.081 [nioEventLoopGroup-2-2] DEBUG io.netty.buffer.AbstractByteBuf - -Dio.netty.buffer.bytebuf.checkAccessible: true</span><br><span class="line">21:26:56.083 [nioEventLoopGroup-2-2] DEBUG io.netty.util.ResourceLeakDetectorFactory - Loaded default ResourceLeakDetector: io.netty.util.ResourceLeakDetector@3520bcf3</span><br><span class="line">21:26:56.099 [nioEventLoopGroup-2-2] INFO com.serilizer.ServerHandler - server received :[tao]</span><br></pre></td></tr></table></figure>

<p>这样就实现了Netty中pb的序列化。</p>
<p>最后，在服务端的使用中，通过Netty内置的ProtobufDecoder指定解码的Class。这个地方只能定义一个class。如果要用通用的格式，那就需要用到自定义消息格式了</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/08/19/%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9CompressedOops/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/08/19/%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9CompressedOops/" class="post-title-link" itemprop="url">指针压缩CompressedOops</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-19 20:40:33" itemprop="dateCreated datePublished" datetime="2022-08-19T20:40:33+08:00">2022-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-18 11:07:24" itemprop="dateModified" datetime="2022-10-18T11:07:24+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在介绍指针压缩前，先说几个对应的名称。</p>
<h1 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a><a href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"></a>对象头</h1><p>众所周知，每个Java对象都有一个对象头。对象头存放着对象在元空间中的地址等等信息。</p>
<h1 id="名称解释："><a href="#名称解释：" class="headerlink" title="名称解释："></a><a href="#%E5%90%8D%E7%A7%B0%E8%A7%A3%E9%87%8A"></a>名称解释：</h1><p>oop (ordinary object pointer) 即普通对象指针，是JVM 中用于引用对象的句柄。可以理解，它就是在对象头中的。</p>
<p>在堆中，32位的对象引用占4个字节，而64位的对象引用占8个字节。也就是说，64位的对象引用大小是32位的2倍。</p>
<h1 id="指针压缩"><a href="#指针压缩" class="headerlink" title="指针压缩"></a><a href="#%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9"></a>指针压缩</h1><p>在64位的JVM中，由于对象引用占用了8个字节。这同时意味着存在几个问题：</p>
<ul>
<li>在JVM中的对象会比32位系统占用更多的堆内存，这样会增加GC的压力</li>
<li>在相同大小的元空间中，64位的JVM只能存储较少的对象元数据信息</li>
<li>降低CPU缓存命中率。64位对象应用的增加，导致CPU只能缓存较少的oop信息，降低了CPU缓存的效率</li>
</ul>
<p>如果64位机器上，oop与32位机器上一致。那就没问题了。主要是这个问题如何解决呢？ 答案是指针压缩。</p>
<blockquote>
<p>指针压缩使得不同的JVM上对象占用空间大小都一样。并且在Jdk8中，指针压缩默认是开启的（网上资料介绍Jdk7中也是默认开启的）。</p>
</blockquote>
<h1 id="开启指针压缩到底哪会不一样呢？"><a href="#开启指针压缩到底哪会不一样呢？" class="headerlink" title="开启指针压缩到底哪会不一样呢？"></a><a href="#%E5%BC%80%E5%90%AF%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9%E5%88%B0%E5%BA%95%E5%93%AA%E4%BC%9A%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2"></a>开启指针压缩到底哪会不一样呢？</h1><p>在JVM中，通过下面设置，可查看指针压缩的工作模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintCompressedOopsMode</span><br></pre></td></tr></table></figure>

<h1 id="查看结果对比"><a href="#查看结果对比" class="headerlink" title="查看结果对比"></a><a href="#%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94"></a>查看结果对比</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    double age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Slf4j(topic = &quot;test&quot;)</span><br><span class="line">public class Test &#123;</span><br><span class="line">    static Person p = new Person();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        log.debug(</span><br><span class="line">        ClassLayout.parseInstance(p).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开启指针压缩模式下的结果："><a href="#开启指针压缩模式下的结果：" class="headerlink" title="开启指针压缩模式下的结果："></a><a href="#%E5%BC%80%E5%90%AF%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BB%93%E6%9E%9C"></a>开启指针压缩模式下的结果：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">heap address: 0x00000005c2200000, size: 8158 MB, Compressed Oops mode: Zero based, Oop shift amount: 3</span><br><span class="line"></span><br><span class="line">Narrow klass base: 0x0000000000000000, Narrow klass shift: 3</span><br><span class="line">Compressed class space size: 1073741824 Address: 0x00000007c0000000 Req Addr: 0x00000007c0000000</span><br><span class="line">15:57:54.480 [main] DEBUG test[36] - 4.0</span><br><span class="line">15:57:54.482 [main] DEBUG test[36] - hashcode:66133adc</span><br><span class="line">15:57:55.584 [main] DEBUG test[36] - com.syn.classlay.Person object internals:</span><br><span class="line">OFF  SZ     TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8          (object header: mark)     0x00000066133adc01 (hash: 0x66133adc; age: 0)</span><br><span class="line">  8   4          (object header: class)    0xf8017a61</span><br><span class="line"> 12   4          (alignment/padding gap)   </span><br><span class="line"> 16   8   double Person.age                0.0</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 4 bytes internal + 0 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<h2 id="关闭指针压缩的场景："><a href="#关闭指针压缩的场景：" class="headerlink" title="关闭指针压缩的场景："></a><a href="#%E5%85%B3%E9%97%AD%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%9C%BA%E6%99%AF"></a>关闭指针压缩的场景：</h2><p>铜鼓-XX:-UseCompressedOops 关闭指针压缩，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OFF  SZ     TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8          (object header: mark)     0x00000066133adc01 (hash: 0x66133adc; age: 0)</span><br><span class="line">  8   8          (object header: class)    0x0000000025d4f1d0</span><br><span class="line"> 16   8   double Person.age                0.0</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a><a href="#%E7%BB%93%E8%AE%BA"></a>结论</h1><p>从指针压缩关闭开启的场景下分析可以知道： 关闭指针压缩的时候，object header: class size&#x3D;8,而关闭的时候，size&#x3D;4</p>
<h1 id="jvm-实现指针压缩的原理"><a href="#jvm-实现指针压缩的原理" class="headerlink" title="jvm 实现指针压缩的原理"></a><a href="#jvm-%E5%AE%9E%E7%8E%B0%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%8E%9F%E7%90%86"></a>jvm 实现指针压缩的原理</h1><p>以下摘录自：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903768077647880">JVM之压缩指针（CompressedOops） - 掘金</a></p>
<p>在实现上，堆中的引用其实还是按照0x0、0x1、0x2…进行存储。只不过当引用被存入64位的寄存器时，JVM将其左移3位（相当于末尾添加3个0），例如0x0、0x1、0x2…分别被转换为0x0、0x8、0x10。而当从寄存器读出时，JVM又可以右移3位，丢弃末尾的0。（oop在堆中是32位，在寄存器中是35位，2的35次方&#x3D;32G。也就是说，使用32位，来达到35位oop所能引用的堆内存空间）</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903768077647880#heading-12">JVM之压缩指针（CompressedOops） - 掘金</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/08/12/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E7%9A%84%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/08/12/%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E7%9A%84%E9%94%81/" class="post-title-link" itemprop="url">系统级别的锁</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-12 20:41:40" itemprop="dateCreated datePublished" datetime="2022-08-12T20:41:40+08:00">2022-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-18 20:00:43" itemprop="dateModified" datetime="2022-10-18T20:00:43+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">Java多线程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在Linux系统上，存在3种不通类型的锁机制：</p>
<ul>
<li>spin： 获取不到锁时，一直自旋</li>
<li>mutex： 或不不到锁时，阻塞。</li>
<li>Semaphore：类似Java种的Semaphore机制。</li>
</ul>
<h1 id="spin-使用："><a href="#spin-使用：" class="headerlink" title="spin 使用："></a><a href="#spin-%E4%BD%BF%E7%94%A8"></a>spin 使用：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int sharei=0;</span><br><span class="line">void increate_num(void);</span><br><span class="line"></span><br><span class="line">pthread_spinlock_t a_lock;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  pthread_spin_init(&amp;a_lock,0);</span><br><span class="line"></span><br><span class="line">  int ret ;</span><br><span class="line"></span><br><span class="line">  pthread_t thread1,thread2,thread3;</span><br><span class="line">  ret = pthread_create(&amp;thread1,NULL,(void *) &amp;increate_num,NULL);</span><br><span class="line">  ret = pthread_create(&amp;thread2,NULL,(void *) &amp;increate_num,NULL);</span><br><span class="line">  ret = pthread_create(&amp;thread3,NULL,(void *) &amp;increate_num,NULL);</span><br><span class="line"></span><br><span class="line">  pthread_join(thread1,NULL);</span><br><span class="line">  pthread_join(thread2,NULL);</span><br><span class="line">  pthread_join(thread3,NULL);</span><br><span class="line"></span><br><span class="line">  printf(&quot;sharei is : %d\n&quot; , sharei);</span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void increate_num(void)&#123;</span><br><span class="line">  pthread_spin_lock(&amp;a_lock);</span><br><span class="line">  long i ,temp;</span><br><span class="line">  for (i =0;i &lt;9999;i++)&#123;</span><br><span class="line">    temp = sharei;</span><br><span class="line">    temp = temp +1;</span><br><span class="line">    sharei = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc spin.c -pthread -o spin</span><br></pre></td></tr></table></figure>

<h1 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a><a href="#mutex"></a>mutex</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int sharei=0;</span><br><span class="line">void increate_num(void);</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  //pthread_spin_init(&amp;a_lock,0);</span><br><span class="line"></span><br><span class="line">  int ret ;</span><br><span class="line"></span><br><span class="line">  pthread_t thread1,thread2,thread3;</span><br><span class="line">  ret = pthread_create(&amp;thread1,NULL,(void *) &amp;increate_num,NULL);</span><br><span class="line">  ret = pthread_create(&amp;thread2,NULL,(void *) &amp;increate_num,NULL);</span><br><span class="line">  ret = pthread_create(&amp;thread3,NULL,(void *) &amp;increate_num,NULL);</span><br><span class="line"></span><br><span class="line">  pthread_join(thread1,NULL);</span><br><span class="line">  pthread_join(thread2,NULL);</span><br><span class="line">  pthread_join(thread3,NULL);</span><br><span class="line"></span><br><span class="line">  printf(&quot;sharei is : %d\n&quot; , sharei);</span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void increate_num(void)&#123;</span><br><span class="line">  long i ,temp;</span><br><span class="line">  for (i =0;i &lt;9999;i++)&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    temp = sharei;</span><br><span class="line">    temp = temp +1;</span><br><span class="line">    sharei = temp;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a><a href="#semaphore"></a>Semaphore</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;semaphore.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE  10</span><br><span class="line">int stack[MAXSIZE];</span><br><span class="line"></span><br><span class="line">int size =0;</span><br><span class="line">sem_t sem;</span><br><span class="line"></span><br><span class="line">void provide_data(void)&#123;</span><br><span class="line">  int i;</span><br><span class="line">  for (i=0;i&lt; MAXSIZE;i++)&#123;</span><br><span class="line">    stack[i]=i;</span><br><span class="line">    sem_post(&amp;sem);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void handle_data(void)&#123;</span><br><span class="line">  int i; </span><br><span class="line">  while((i = size++)&lt; MAXSIZE)&#123;</span><br><span class="line">    sem_wait(&amp;sem);</span><br><span class="line">    printf(&quot;cross: %d x %d= %d \n&quot;,stack[i],stack[i],stack[i]*stack[i]);</span><br><span class="line">    usleep(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  pthread_t provider,consume;</span><br><span class="line">  sem_init(&amp;sem,0,0);</span><br><span class="line">  pthread_create(&amp;provider,NULL,(void *)provide_data,NULL);</span><br><span class="line">  pthread_create(&amp;consume,NULL,(void *)handle_data,NULL);</span><br><span class="line">  pthread_join(provider,NULL);</span><br><span class="line">  pthread_join(consume,NULL);</span><br><span class="line">  sem_destroy(&amp;sem);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tao-yb.github.io/blogs/2022/08/11/%E5%AF%B9%E8%B1%A1%E5%A4%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.gif">
      <meta itemprop="name" content="tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="javaer">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | javaer">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/blogs/2022/08/11/%E5%AF%B9%E8%B1%A1%E5%A4%B4/" class="post-title-link" itemprop="url">对象头</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-11 20:40:05" itemprop="dateCreated datePublished" datetime="2022-08-11T20:40:05+08:00">2022-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-18 11:07:21" itemprop="dateModified" datetime="2022-10-18T11:07:21+08:00">2022-10-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/blogs/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>查看对象头。我们常说对象头，但是对象头到底里面是什么呢？ 为查看对象头，我们引用jol-core</p>
<h1 id="pom引用"><a href="#pom引用" class="headerlink" title="pom引用"></a><a href="#pom%E5%BC%95%E7%94%A8"></a>pom引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.16&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a><a href="#%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"></a>定义对象</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查看对象的对象头"><a href="#查看对象的对象头" class="headerlink" title="查看对象的对象头"></a><a href="#%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%A4%B4"></a>查看对象的对象头</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.syn.classlay;</span><br><span class="line"></span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** * @author tyb * @Description</span><br><span class="line"> * @create 2022-07-29 21:21 */</span><br><span class="line">@Slf4j(topic = &quot;test&quot;)</span><br><span class="line">public class Test &#123;</span><br><span class="line">    static Person p = new Person();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //log.debug(&quot;hashcode:&#123;&#125;&quot;,Integer.toHexString(p.hashCode()));</span><br><span class="line">        log.debug(</span><br><span class="line">        ClassLayout.parseInstance(p).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日志定义（logback-xml）："><a href="#日志定义（logback-xml）：" class="headerlink" title="日志定义（logback.xml）："></a><a href="#%E6%97%A5%E5%BF%97%E5%AE%9A%E4%B9%89logbackxml"></a>日志定义（logback.xml）：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;Pattern&gt;</span><br><span class="line">                %d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger[36] - %msg%n</span><br><span class="line">            &lt;/Pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;logger name=&quot;test&quot; level=&quot;debug&quot; additivity=&quot;false&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;&gt;&lt;/appender-ref&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line"></span><br><span class="line">    &lt;root level=&quot;error&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><a href="#%E8%BE%93%E5%87%BA"></a>输出：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">21:36:07.564 [main] DEBUG test[36] - com.syn.classlay.Person object internals:</span><br><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf8017a61</span><br><span class="line"> 12   4        (object alignment gap)    </span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>如果给对象Person 加一个整数字段，再次查看对象头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OFF  SZ   TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8        (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4        (object header: class)    0xf8017a61</span><br><span class="line"> 12   4    int Person.age                0</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>从上面信息可知：</p>
<ul>
<li>对象头中的Mark占用8字节 64位</li>
<li>对象头中的class占用4字节 32位</li>
</ul>
<h1 id="object-header"><a href="#object-header" class="headerlink" title="object header"></a><a href="#object-header"></a>object header</h1><h2 id="object-header-1"><a href="#object-header-1" class="headerlink" title="object header"></a><a href="#object-header-2"></a>object header</h2><blockquote>
<p>object header Common structure at the beginning of every GC-managed heap object. (Every oop points to an object header.) Includes fundamental information about the heap object’s layout, type, GC state, synchronization state, and identity hash code. Consists of two words. In arrays it is immediately followed by a length field. Note that both Java objects and VM-internal objects have a common object header format.</p>
</blockquote>
<p>object header中又包括：</p>
<ul>
<li>the heap object’s layout</li>
<li>type</li>
<li>GC state</li>
<li>synchronization state</li>
<li>identity hash code</li>
</ul>
<p>它由2部分组成： mark word,klass pointer</p>
<h3 id="mark-word"><a href="#mark-word" class="headerlink" title="mark word"></a><a href="#mark-word"></a>mark word</h3><p>它占用8bytes</p>
<blockquote>
<p>mark word The first word of every object header. Usually a set of bitfields including synchronization state and identity hash code. May also be a pointer (with characteristic low bit encoding) to synchronization related information. During GC, may contain GC state bits.</p>
</blockquote>
<h3 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a><a href="#klass-pointer"></a>klass pointer</h3><blockquote>
<p>The second word of every object header. Points to another object (a metaobject) which describes the layout and behavior of the original object. For Java objects, the “klass” contains a C++ style “vtable”.</p>
</blockquote>
<p>它占用4bytes 或者8bytes。如果开启指针压缩的话，就只占用4bytes。jdk8中，类加载的metadata信息放在元空间。klass pointer指向元空间的地址。</p>
<h1 id="大端存储与小端存储"><a href="#大端存储与小端存储" class="headerlink" title="大端存储与小端存储"></a><a href="#%E5%A4%A7%E7%AB%AF%E5%AD%98%E5%82%A8%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8"></a>大端存储与小端存储</h1><p>高字节存放在高地址，底字节存低地址。因此，hashcode的二进制中，由于小端存储，因此hashcode是反过来的。</p>
<p>数据的高位字节在前（内存的低地址），低位字节在后。这样的存储模式类似于把数据当做字符串处理，内存地址由小到大增长</p>
<blockquote>
<p>jol-core 不同版本打印的数据有存在差异。可以使用10版本查看到字节输出。如jol 0.10 版本的输出：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18:47:59.604 [main] DEBUG test[36] - hashcode:1517365b</span><br><span class="line">18:48:00.805 [main] DEBUG test[36] - com.syn.classlay.Person object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 5b 36 17 (00000001 01011011 00110110 00010111) (389438209)</span><br><span class="line">      4     4        (object header)                           15 00 00 00 (00010101 00000000 00000000 00000000) (21)</span><br><span class="line">      8     4        (object header)                           61 7a 01 f8 (01100001 01111010 00000001 11111000) (-134120863)</span><br><span class="line">     12     4    int Person.age                                0</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>长度说明（一共8字节）：</p>
<ul>
<li>unused 25位</li>
<li>hashcode 31 位</li>
<li>未用到 1 位</li>
<li>age 4 位</li>
<li>偏向锁标识：1 位</li>
<li>锁状态：2 位</li>
</ul>
<p>从上面hashcode和对象头输出可以看到，由于小端存储，hashcode的输出的相反的。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7b1c6d7394e2">https://www.jianshu.com/p/7b1c6d7394e2</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blogs/page/2/">2</a><a class="extend next" rel="next" href="/blogs/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/blogs/js/comments.js"></script><script src="/blogs/js/utils.js"></script><script src="/blogs/js/motion.js"></script><script src="/blogs/js/schemes/muse.js"></script><script src="/blogs/js/next-boot.js"></script>

  





  





</body>
</html>
