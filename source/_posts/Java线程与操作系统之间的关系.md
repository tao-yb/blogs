---
title: Java线程与操作系统之间的关系
date: 2022-08-10 20:39:21
tags: 
- java
- 多线程
categories: Java多线程
---

在Linux上，通过pthread_create系统接口可以创建一个线程。我们在Java中，通过new Thread创建出来的线程其实是JVM通过调用pthread_create 创建的。

本例中，演示在Java程序中，通过调用pthread_create系统接口创建。涉的相关知识点包括：

- jni
- gcc

# [](#总体流程概述)总体流程概述：

在Java文件中，native 方法如果能调用到C文件中通过pthread_create创建的线程。

> 首先创建com/my目录（根据java 文件包名创建）。以下所有文件都在com/my下

```
前置条件：需要一个C文件（myThread.c）。在c文件中，通过pthread_Create创建线程。也就是Java中，thread启动的线程就是pthread_Create创建的。
```

myThread.c 文件内容：

```
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>
// com_my_ZLThread.h文件是下面使用javac -h生成的文件
#include "com_my_ZLThread.h"

pthread_t pid;

void* thread_entity(void* arg){
    while(1){
       usleep(100);
       printf("i am a new thread \n");
   }

}

//这个地方直接拷贝com_my_ZLThread.h中的即可
JNIEXPORT void JNICALL Java_com_my_ZLThread_start1(JNIEnv *env, jobject cl){
    //创建线程
    pthread_create(&pid,NULL,thread_entity,NULL);
    while(1){
        usleep(100);
        printf("main thread \n");

    }
}
```

## [](#定义java类)定义Java类

```
package com.my;

/** * @author tyb * @Description
 * @create 2022-07-18 20:41 */
public class ZLThread {

    //装载我们自己类库。在类库中，调用pthread_create创建线程
    static {
        System.loadLibrary("OSThreadNative");
    }

    // 定义native方法。这个方法能调用到OSThreadNative中pthread_create中线程相关方法
    public native void start1();

    public static void main(String[] args) {
        ZLThread thread = new ZLThread();
        // 能调用到c 文件中的方法，通过pthread_create创建线程
        thread.start1();
    }
}
```

## [](#利用jni调用本地方法)利用jni调用本地方法

#### [](#使用javac-生成native-header文件)使用javac ，生成native header文件。

```
javac -h . ZLThread.java
```

生成文件如下：

```
-rw-r--r-- 1 root root  404 Jul 23 19:03 com_my_ZLThread.h
-rw-r--r-- 1 root root  469 Jul 23 19:03 ZLThread.class
-rw-r--r-- 1 root root  349 Jul 23 19:00 ZLThread.java
```

### [](#com_my_zlthreadh-文件)com_my_ZLThread.h 文件

```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_my_ZLThread */

#ifndef _Included_com_my_ZLThread
#define _Included_com_my_ZLThread
#ifdef __cplusplus
extern "C" {
#endif
/* * Class:     com_my_ZLThread * Method:    start1 * Signature: ()V */
JNIEXPORT void JNICALL Java_com_my_ZLThread_start1
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

## [](#将mythreadc文件编译成so-文件)将myThread.c文件编译成so 文件

```
gcc -fPIC -I /home/tyb/java-env/jdk1.8.0_131/include -I /home/tyb/java-env/jdk1.8.0_131/include/linux/ -shared -o libOsThreadNative.so myThread.c
```

gcc 相关参数说明： -I 指定jdk中jni.h文件路径（一般jdk的include下有jni.h文件） -o 编译输出的库文件名。libOsThreadNative即最后Java文件中使用的是OsThreadNative库

编译完后目录下会多一个libOsThreadNative.so文件

```
-rw-r--r-- 1 root root  404 Jul 23 19:03 com_my_ZLThread.h
-rwxr-xr-x 1 root root 8088 Jul 23 19:30 libOsThreadNative.so*
-rw-r--r-- 1 root root  430 Jul 22 21:08 myThread.c
-rw-r--r-- 1 root root  469 Jul 23 19:03 ZLThread.class
-rw-r--r-- 1 root root  349 Jul 23 19:00 ZLThread.java
```

# [](#将库文件加入到lib库中)将库文件加入到lib库中

> Java不会在当前目录下找，他需要从class path 中找。因此需要加入到加载库中

```
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/study-c/
```

# [](#运行)运行

```
//注意，如果ZLThread.class文件就在com/my下。此时还是需要在com/my下再次创建com/my文件，并将ZLThread.class移到com/my文件夹下
java com.my.ZLThread。
```

输出结果：

```
i am a new thread 
main thread 
i am a new thread 
main thread 
i am a new thread 
main thread 
i am a new thread 
main thread 
i am a new thread 
main thread 
i am a new thread 
i am a new thread 
main thread 
i am a new thread 
main thread 
i am a new thread 
main thread 
i am a new thread 
i am a new thread 
main thread 
i am a new thread 
i am a new thread 
main thread 
```
